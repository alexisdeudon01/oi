#!/usr/bin/env python3
"""
Script de gestion compl√®te de l'infrastructure IDS.

Fonctionnalit√©s:
- Gestion Tailscale (devices, keys, connexions)
- Gestion AWS OpenSearch (domaines, index)
- Gestion Raspberry Pi (services, Docker, monitoring)

Usage:
    python scripts/manage_infrastructure.py [command] [options]

Commands:
    tailscale list-devices          Liste les devices Tailscale
    tailscale ping <ip>             Ping un device
    tailscale create-key            Cr√©e une auth key

    opensearch create-domain <name> Cr√©e un domaine OpenSearch
    opensearch list-domains         Liste les domaines
    opensearch list-indexes <endpoint> Liste les index

    pi info                         Infos syst√®me du Pi
    pi services                     Liste les services
    pi docker-ps                    Liste les conteneurs Docker
    pi restart-service <name>       Red√©marre un service
"""

import asyncio
import getpass
import sys
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from ids.managers import (
    OpenSearchDomainManager,
    RaspberryPiManager,
    TailscaleManager,
)

# =========================================================================
# Tailscale Commands
# =========================================================================


async def tailscale_list_devices(api_key: str, tailnet: str):
    """Liste les devices Tailscale."""
    async with TailscaleManager(api_key, tailnet) as manager:
        devices = await manager.list_devices()

        print(f"\nüì° Tailscale Devices ({len(devices)} total)\n")
        print(f"{'Name':<20} {'IP':<18} {'OS':<15} {'Status':<10} {'Tags'}")
        print("=" * 80)

        for device in devices:
            ip = device.addresses[0] if device.addresses else "N/A"
            status = "üü¢ Online" if device.online else "üî¥ Offline"
            tags = ", ".join(device.tags) if device.tags else "-"
            print(f"{device.name:<20} {ip:<18} {device.os:<15} {status:<10} {tags}")


async def tailscale_ping(api_key: str, tailnet: str, ip_address: str):
    """Ping un device Tailscale."""
    async with TailscaleManager(api_key, tailnet) as manager:
        device = await manager.find_device_by_ip(ip_address)

        if not device:
            print(f"‚ùå Device not found: {ip_address}")
            return

        print(f"\nüì° Pinging {device.name} ({ip_address})...")
        latency = manager.ping_device(ip_address, count=4)

        if latency:
            print(f"‚úÖ Average latency: {latency:.2f}ms")
        else:
            print(f"‚ùå Ping failed")


async def tailscale_create_key(api_key: str, tailnet: str):
    """Cr√©e une auth key Tailscale."""
    description = input("Description (default: Generated by IDS): ").strip() or "Generated by IDS"
    reusable = input("Reusable? (y/n, default: y): ").strip().lower() != "n"
    preauth = input("Preauthorized? (y/n, default: y): ").strip().lower() != "n"
    tags_input = input("Tags (comma-separated, ex: tag:server,tag:prod): ").strip()
    tags = [t.strip() for t in tags_input.split(",") if t.strip()] if tags_input else None

    async with TailscaleManager(api_key, tailnet) as manager:
        key = await manager.create_auth_key(
            description=description,
            reusable=reusable,
            preauthorized=preauth,
            tags=tags,
        )

        print(f"\n‚úÖ Auth key created:")
        print(f"   {key}")
        print(f"\nüí° Use this key to connect new devices:")
        print(f"   tailscale up --authkey={key}")


# =========================================================================
# OpenSearch Commands
# =========================================================================


def opensearch_create_domain(
    aws_access_key: str,
    aws_secret_key: str,
    region: str,
    domain_name: str,
):
    """Cr√©e un domaine OpenSearch."""
    manager = OpenSearchDomainManager(
        aws_access_key_id=aws_access_key,
        aws_secret_access_key=aws_secret_key,
        region=region,
    )

    print(f"\nüî® Creating OpenSearch domain: {domain_name}")
    print(f"   Region: {region}")
    print(f"   Instance: t3.small.search")
    print(f"   Storage: 10GB gp3")

    status = manager.create_domain(
        domain_name=domain_name,
        instance_type="t3.small.search",
        instance_count=1,
        volume_size_gb=10,
        wait=True,
        timeout=1800,
    )

    print(f"\n‚úÖ Domain created:")
    print(f"   Name: {status.domain_name}")
    print(f"   ID: {status.domain_id}")
    print(f"   Endpoint: {status.endpoint}")
    print(f"   Engine: {status.engine_version}")


def opensearch_list_domains(aws_access_key: str, aws_secret_key: str, region: str):
    """Liste les domaines OpenSearch."""
    manager = OpenSearchDomainManager(
        aws_access_key_id=aws_access_key,
        aws_secret_access_key=aws_secret_key,
        region=region,
    )

    domains = manager.list_domains()

    print(f"\nüìä OpenSearch Domains ({len(domains)} total)\n")

    for domain_name in domains:
        status = manager.get_domain_status(domain_name)
        if status:
            processing = "üîÑ Processing" if status.processing else "‚úÖ Ready"
            print(f"  ‚Ä¢ {domain_name}")
            print(f"    Endpoint: {status.endpoint or 'N/A'}")
            print(f"    Status: {processing}")
            print(f"    Engine: {status.engine_version}")
            print()


def opensearch_list_indexes(
    aws_access_key: str,
    aws_secret_key: str,
    region: str,
    endpoint: str,
):
    """Liste les index d'un domaine."""
    manager = OpenSearchDomainManager(
        aws_access_key_id=aws_access_key,
        aws_secret_access_key=aws_secret_key,
        region=region,
    )

    indexes = manager.list_indexes(endpoint)

    print(f"\nüìö OpenSearch Indexes ({len(indexes)} total)\n")
    print(f"{'Name':<40} {'Health':<10} {'Docs':<12} {'Size':<12}")
    print("=" * 80)

    for idx in indexes:
        health_icon = {"green": "üü¢", "yellow": "üü°", "red": "üî¥"}.get(idx.health, "‚ö™")
        size_mb = idx.size_bytes / (1024 * 1024)
        print(f"{idx.name:<40} {health_icon} {idx.health:<8} {idx.doc_count:<12} {size_mb:.2f} MB")


# =========================================================================
# Raspberry Pi Commands
# =========================================================================


def pi_info(host: str, user: str, ssh_key: str):
    """Affiche les infos syst√®me du Pi."""
    with RaspberryPiManager(host, user, ssh_key_path=ssh_key) as pi:
        info = pi.get_system_info()

        print(f"\nüçì Raspberry Pi Information\n")
        print(f"  Hostname:     {info.hostname}")
        print(f"  Model:        {info.model}")
        print(f"  OS:           {info.os_version}")
        print(f"  Kernel:       {info.kernel_version}")
        print(f"  Architecture: {info.architecture}")
        print(f"  CPUs:         {info.cpu_count}")
        print(f"  Memory:       {info.total_memory_mb} MB")

        if info.cpu_temperature:
            print(f"  Temperature:  {info.cpu_temperature:.1f}¬∞C")

        if info.load_average:
            print(
                f"  Load Avg:     {info.load_average[0]:.2f}, {info.load_average[1]:.2f}, {info.load_average[2]:.2f}"
            )

        if info.disk_usage_percent:
            print(f"  Disk Usage:   {info.disk_usage_percent:.1f}%")


def pi_services(host: str, user: str, ssh_key: str):
    """Liste les services IDS."""
    services = ["ids2-agent.service", "suricata.service", "docker.service"]

    with RaspberryPiManager(host, user, ssh_key_path=ssh_key) as pi:
        print(f"\n‚öôÔ∏è  Services Status\n")
        print(f"{'Service':<30} {'Active':<10} {'Enabled':<10} {'Running'}")
        print("=" * 70)

        for service_name in services:
            try:
                status = pi.get_service_status(service_name)
                active = "‚úÖ Yes" if status.active else "‚ùå No"
                enabled = "‚úÖ Yes" if status.enabled else "‚ùå No"
                running = "üü¢ Yes" if status.running else "üî¥ No"
                print(f"{service_name:<30} {active:<10} {enabled:<10} {running}")
            except Exception as e:
                print(f"{service_name:<30} ‚ùå Error: {e}")


def pi_docker_ps(host: str, user: str, ssh_key: str):
    """Liste les conteneurs Docker."""
    with RaspberryPiManager(host, user, ssh_key_path=ssh_key) as pi:
        containers = pi.list_containers()

        print(f"\nüê≥ Docker Containers ({len(containers)} total)\n")
        print(f"{'Name':<20} {'Image':<30} {'Status':<20}")
        print("=" * 80)

        for container in containers:
            status_icon = "üü¢" if "running" in container.status.lower() else "üî¥"
            print(f"{container.name:<20} {container.image:<30} {status_icon} {container.status}")


def pi_restart_service(host: str, user: str, ssh_key: str, service_name: str):
    """Red√©marre un service."""
    with RaspberryPiManager(host, user, ssh_key_path=ssh_key) as pi:
        print(f"\nüîÑ Restarting {service_name}...")
        success = pi.restart_service(service_name)

        if success:
            print(f"‚úÖ Service restarted successfully")
        else:
            print(f"‚ùå Failed to restart service")


# =========================================================================
# Main CLI
# =========================================================================


def main():
    """Point d'entr√©e principal."""
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    command = sys.argv[1]

    # Tailscale commands
    if command == "tailscale":
        if len(sys.argv) < 3:
            print("Usage: manage_infrastructure.py tailscale <subcommand>")
            sys.exit(1)

        subcommand = sys.argv[2]
        api_key = getpass.getpass("Tailscale API Key: ")
        tailnet = input("Tailnet Name: ").strip()

        if subcommand == "list-devices":
            asyncio.run(tailscale_list_devices(api_key, tailnet))
        elif subcommand == "ping" and len(sys.argv) >= 4:
            asyncio.run(tailscale_ping(api_key, tailnet, sys.argv[3]))
        elif subcommand == "create-key":
            asyncio.run(tailscale_create_key(api_key, tailnet))
        else:
            print(f"Unknown tailscale subcommand: {subcommand}")

    # OpenSearch commands
    elif command == "opensearch":
        if len(sys.argv) < 3:
            print("Usage: manage_infrastructure.py opensearch <subcommand>")
            sys.exit(1)

        subcommand = sys.argv[2]
        aws_key = getpass.getpass("AWS Access Key ID: ")
        aws_secret = getpass.getpass("AWS Secret Access Key: ")
        region = input("AWS Region (default: eu-central-1): ").strip() or "eu-central-1"

        if subcommand == "create-domain" and len(sys.argv) >= 4:
            opensearch_create_domain(aws_key, aws_secret, region, sys.argv[3])
        elif subcommand == "list-domains":
            opensearch_list_domains(aws_key, aws_secret, region)
        elif subcommand == "list-indexes" and len(sys.argv) >= 4:
            opensearch_list_indexes(aws_key, aws_secret, region, sys.argv[3])
        else:
            print(f"Unknown opensearch subcommand: {subcommand}")

    # Raspberry Pi commands
    elif command == "pi":
        if len(sys.argv) < 3:
            print("Usage: manage_infrastructure.py pi <subcommand>")
            sys.exit(1)

        subcommand = sys.argv[2]
        host = input("Pi IP (default: 100.118.244.54): ").strip() or "100.118.244.54"
        user = input("Pi User (default: pi): ").strip() or "pi"
        ssh_key = (
            input("SSH Key Path (default: ~/.ssh/pi_github_actions): ").strip()
            or "~/.ssh/pi_github_actions"
        )
        ssh_key = str(Path(ssh_key).expanduser())

        if subcommand == "info":
            pi_info(host, user, ssh_key)
        elif subcommand == "services":
            pi_services(host, user, ssh_key)
        elif subcommand == "docker-ps":
            pi_docker_ps(host, user, ssh_key)
        elif subcommand == "restart-service" and len(sys.argv) >= 4:
            pi_restart_service(host, user, ssh_key, sys.argv[3])
        else:
            print(f"Unknown pi subcommand: {subcommand}")

    else:
        print(f"Unknown command: {command}")
        print(__doc__)
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Interrupted")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)
